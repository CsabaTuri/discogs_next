import React from "react";
import Head from "next/head";
import { useRouter } from 'next/router'
import Row from "react-bootstrap/Row";
import Col from "react-bootstrap/Col";
import Button from "react-bootstrap/Button";
import Form from "react-bootstrap/Form";
import createClient from "../services/client/client";
import { SEARCH } from "../services/client/queries";
import Layout from "../src/components/layout";
import Artist from "../src/components/results/artist";
import Label from "../src/components/results/label";
import Master from "../src/components/results/master";
import Release from "../src/components/results/release";
import { serverSideTranslations } from "next-i18next/serverSideTranslations";
import { requireAuthentication } from "../services/auth/requireAuthentication";
import { useTranslation } from "next-i18next";
import {
  IndexData,
  SearchDataType,
  CTX,
} from "../types";
import Searching from "../src/components/searching";

const initialSearchData: SearchDataType = {
  query: "",
  artist: "",
  label: "",
  year: "",
  style: "",
  genre: "",
  country: "",
  type: "all",
  per_page: "10"
};

export default function Home(props: any): React.ReactElement {
  const { t } = useTranslation("common");
  const router = useRouter()
  const [data, setData] = React.useState<IndexData | undefined>();
  const [favoriteArtistId, setFavoriteArtistId] = React.useState<number[]>([]);
  const [favoriteMasterId, setFavoriteMasterId] = React.useState<number[]>([]);
  const [favoriteReleaseId, setFavoriteReleaseId] = React.useState<number[]>(
    []
  );
  const [favoriteLabelId, setFavoriteLabelId] = React.useState<number[]>([]);
  const [isLoad, setIsLoad] = React.useState<boolean>(true);
  const [page, setPage] = React.useState<string>("1");
  const [per_page, setPer_page] = React.useState<string>("10");
  const [searchData, setSearchData] = React.useState<SearchDataType>(
    initialSearchData
  );
  function clean(obj: any) {
    for (var propName in obj) {
      if (obj[propName] === "" || obj[propName] === undefined) {
        delete obj[propName];
      }
    }
    return obj
  }
  React.useEffect(() => {
    setIsLoad(true);
    search();
    setIsLoad(false);
  }, [props]);
  React.useEffect(() => {
    setIsLoad(true);
    search();
    setIsLoad(false);
  }, []);
  function next(): void {
    searchData.page = (parseInt(page) + 1).toString()
    router.push({ pathname: '/', query: clean(searchData) })
  }
  function prev(): void {
    if (parseInt(page) > 1) {
      searchData.page = (parseInt(page) - 1).toString()
      router.push({ pathname: '/', query: clean(searchData) })
    }
  }
  function first(): void {
    searchData.page = "1"
    router.push({ pathname: '/', query: clean(searchData) })
  }
  function last(): void {
    searchData.page = props.data.search.pagination.pages.toString()
    router.push({ pathname: '/', query: clean(searchData) })
  }
  function perPageChange(e: React.ChangeEvent<HTMLInputElement>): void {
    const { value } = e.target
    searchData.per_page = value
    router.push({ pathname: '/', query: clean(searchData) })
  }
  function reset(): void {
    setSearchData(initialSearchData);
    search();
  }
  function handleChange(e: React.ChangeEvent<HTMLInputElement>): void {
    const { name, value } = e.target;
    setSearchData((inputs) => ({ ...inputs, [name]: value }));
  }
  async function search(): Promise<void> {
    setSearchData(props.q)
    setPage(props.data.search.pagination.page)
    setPer_page(props.q.per_page || "10")
    setData(props.data.search);
    let ArtistIds: number[] = [];
    let MasterIds: number[] = [];
    let ReleaseIds: number[] = [];
    let LabelIds: number[] = [];
    await props.data.getFavoritesArtist.map((id: any) => {
      ArtistIds.push(parseInt(id.artist_id));
    });
    await props.data.getFavoritesMaster.map((id: any) => {
      MasterIds.push(parseInt(id.master_id));
    });
    await props.data.getFavoritesRelease.map((id: any) => {
      ReleaseIds.push(parseInt(id.release_id));
    });
    await props.data.getFavoritesLabel.map((id: any) => {
      LabelIds.push(parseInt(id.label_id));
    });
    await setFavoriteArtistId(ArtistIds);
    await setFavoriteMasterId(MasterIds);
    await setFavoriteReleaseId(ReleaseIds);
    await setFavoriteLabelId(LabelIds);
  }
  return (
    <Layout>
      <Head>
        <title>Discogs</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <Col>

        <Searching
          handleChange={handleChange}
          searchData={searchData}
          reset={reset}
        />
        {isLoad ? <>Loading...</> : <Row className="justify-content-md-center">
          <Col>
            <p>{t("item")}:{props.data.search.pagination.items}</p>
            <p >{t("page")}:{`${page}/${props.data.search.pagination.pages}`}</p>
            <div style={{ display: "inline" }}>
              <Form.Label>{`${t("item")}/${t("page")}`}:</Form.Label>
              <Form.Control
                as="select"
                name="per_page"
                onChange={perPageChange}
                value={per_page}
                style={{ maxWidth: "60px", display: "inline" }}
              >
                <option value="10">10</option>
                <option value="20">20</option>
                <option value="50">50</option>
                <option value="100">100</option>
              </Form.Control>
            </div>
            <Button variant="outline-info" onClick={first}>
              {t("first")}
            </Button>
            <Button variant="outline-info" onClick={prev}>
              {t("prev")}
            </Button>
            <Button variant="outline-info" onClick={next}>
              {t("next")}
            </Button>
            <Button variant="outline-info" onClick={last}>
              {t("last")}
            </Button>
            <hr />
            {!isLoad && !!data && !!data.results && data.results.length > 0
              ? data.results.map((result) => {
                if (result.type === "artist") {
                  return <Artist data={result} ids={favoriteArtistId} />;
                }
                if (result.type === "master") {
                  return <Master data={result} ids={favoriteMasterId} />;
                }
                if (result.type === "label") {
                  return <Label data={result} ids={favoriteLabelId} />;
                }
                if (result.type === "release") {
                  return <Release data={result} ids={favoriteReleaseId} />;
                }
              })
              : null}
            <hr />
            <p>{t("item")}:{props.data.search.pagination.items}</p>
            <p >{t("page")}:{`${page}/${props.data.search.pagination.pages}`}</p>
            <div style={{ display: "inline" }}>
              <Form.Label>{`${t("item")}/${t("page")}`}:</Form.Label>
              <Form.Control
                as="select"
                name="per_page"
                onChange={perPageChange}
                value={per_page}
                style={{ maxWidth: "60px", display: "inline" }}
              >
                <option value="10">10</option>
                <option value="20">20</option>
                <option value="50">50</option>
                <option value="100">100</option>
              </Form.Control>
            </div>
            <Button variant="outline-info" onClick={prev}>
              {t("prev")}
            </Button>
            <Button variant="outline-info" onClick={next}>
              {t("next")}
            </Button>
          </Col>
        </Row>}
      </Col>
    </Layout >
  );
}
export const getServerSideProps: any = requireAuthentication(
  async (context: CTX) => {
    const locale: string = context.locale;
    const token = JSON.parse(JSON.stringify(context.req.cookies)).token || "";
    const { query: q } = context
    const { artist, label, query, year, style, genre, type, country, page, per_page } = context.query
    const client = createClient(token);
    const { data, errors } = await client.query({
      query: SEARCH,
      variables: {
        artist: artist || "",
        label: label || "",
        query: query || "",
        year: year || "",
        style: style || "",
        genre: genre || "",
        type: type || "",
        country: country || "",
        page: page || "1",
        per_page: per_page || "10",
      },
    });
    let errorCode = errors ? errors : false;
    if (errorCode) {
      context.res.statusCode = 404;
    }
    return { props: { errorCode, data, q, ...await serverSideTranslations(locale, ['common']) } };
  }
);
